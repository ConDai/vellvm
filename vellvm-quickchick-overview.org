* Introduction

This project is the start of a suite of QuickChick generators for LLVM
code, with the purpose of testing the Vellvm project. In the near term
we simply want to compare Vellvm's interpreter to ~clang~ in order to
find disagreements with Vellvm's semantics, but we are hoping that
this will lay the ground work for automatically testing if an
optimization of LLVM code preserves the semantics of programs.

* Updating Backtracking QuickChick

The first step of this project was to get the backtracking version of
QuickChick up to speed. We wanted to use Coq 8.11 in order to take
advantage of the easy way to turn off the termination checker in Coq
8.11 (some of the generators use complex non-structural recursion, and
since these generators will not be used in proofs it's better not to
waste time and effort guaranteeing their termination). This took a little bit
of effort at first, as quite a lot has changed in QuickChick since the
backtracking branch was last updated --- all of the combinators have
new names, and a lot of the ml code has changed as well!

Vellvm also required some hacking and admitted lemmas to work on 8.11,
but this should be fixed soon in a new release of Vellvm.

* Overview of Generators

The generators live here:

https://github.com/vellvm/vellvm/blob/quickchick/src/coq/GenAST.v

We wanted to start with a simple subset of LLVM -- LLVM is quite a
large language to begin with, and there are many different constraints
that the generator might need to take into account depending on the
context.

For instance the types in LLVM programs have different
constraints at many different points. In some places only non-void
types are valid, some places need types to have sizes, and other
places can only have integer types. This is not a huge problem, but it
does result in us building many different type generators.

The generators themselves are relatively straightforward, save for
some tuning to ensure that we use previously generated variables and
to ensure we generate programs with reasonable sizes. For the most
part these generators just reflect the structure of the LLVM AST,
making sure to call generators that satisfy the right constraints for
different components.

The most complicated generator is the one for terminators and
blocks. These generators are mutually recursive, as when we generate a
branching terminator we need to generate blocks to branch to, and
similarly when we generate a block we need to be able to generate
terminators. Currently we do not create branches into already existing
blocks in order to make sure all of our programs terminate to ease
testing, though this is something that we hope to improve on in the
future---for instance it might be nice to automatically generate loops
over arrays like Csmith does, and it might be nice to relax this
restriction and rely upon timeouts.

** Avoiding Errors

Currently we do not perform much static analysis like Csmith in order
to avoid generating terms which trigger undefined behaviour. We use a
number of simple techniques to avoid some common cases of undefined
behaviour and errors in programs.

For instance, to avoid division by 0 we currently only generate
division (and mod) instructions with constant, non-zero valued
denominators. In principle it should be possible to use variables in
the denominator, but we would have to perform some analysis in order
to make sure that the identifiers chosen are non-zero. This analysis
should be fairly easy under the current restrictions for the CFGs that
we are generating, however we believe that we will get more
interesting programs in the future by generating more complicated CFGs
(with back edges and phi nodes) that would would make this analysis
obsolete anyway.

We also make some efforts to not generate garbage pointers. Currently
all pointers must come from the ~alloca~ instruction, which allocates
space on the stack for a value. To ensure that we do not load from
uninitialized memory, every ~alloca~ is paired with a ~store~ that
initializes the allocated memory.

* Show instances

It's useful to test generators with ~Sample~ while building them. This
has proven to be a little painful because Vellvm lacked ~Show~
instances for almost all of the AST, and what is there used the
~Ceres~ library in Coq, which (unfortunately) sometimes causes
segmentation faults in QuickChick due to how ~nat~ was getting
serialized. Eventually we gave up on extending the ~Ceres~
serialization of the AST, and instead manually wrote ~Show~ instances
for the parts of the AST that we actually generate.

These ~Show~ instances are not only useful for testing the generators,
but they're also useful for the properties we want to test, as we want
to serialize the ASTs into LLVM programs that ~clang~ can parse.

* Properties under test

  The properties that we are testing live here:

  https://github.com/vellvm/vellvm/blob/quickchick/src/coq/QCVellvm.v  

  As a first step, we are using QuickChick to differentially test the
  Vellvm interpreter against the ~clang~ compiler. We take advantage
  of Coq's ~Extract Constant~ mechanism to build an ml function that
  pretty prints the AST into LLVM IR, passes this IR to ~clang~, and
  then runs the resulting executable. The return code from the
  executed program can then be compared against the result we get from
  interpreting the function using Vellvm's interpreter.

  We believe that we should be able to test certain ~eutt~ relations
  automatically using QuickChick as well, which we hope will help with
  testing program transformations within Vellvm. The idea is to
  compare the trees up to a finite depth, like testing if prefixes of
  streams are equal. The ~Tau t~ and ~Ret x~ constructors in
  interaction trees are simple to handle --- ~Tau~ nodes can be
  automatically stripped, and ~Ret~ nodes can be compared
  directly. The difficulty in testing ~eutt~ is with ~Vis e k~
  nodes. If we have ~eutt (Vis e1 k1) (Vis e2 k2)~, then we just need
  to make sure that ~e1 = e2~, and then in principle it should just be
  a matter of providing the same (possibly randomly generated) value
  to each of the continuations. More work needs to be done on this,
  but in principle it should be possible to do something here.

* Future Work

** Testing of undef

LLVM has a notion of nondeterminism called ~undef~ which is used for
performing optimizations. A value of ~undef~ essentially means "I
don't care what this value is" and is used to represent things like
uninitialized variables. The compiler is allowed to concretize ~undef~
values into any value it finds convenient. It can replace ~undef~ with
whatever is left in a machine register, or it can always replace it
with 0. The semantics of an LLVM program is actually a set of traces,
where each trace makes different choices for what the ~undef~ values
are in the program. Having multiple allowable behaviours grants the
compiler more flexibility, which can lead to more efficient programs,
but multiple behaviours also means that we can't simply compare the
output of ~clang~ and ~vellvm~ for instance. The ~clang~ compiler
might make different choices than ~vellvm~, but they might both be
valid. This makes simple differential testing no longer an
option. Vellvm does have a propositional semantics which collects all
of the possible traces, and in theory some kind of automated theorem
proving might be able to prove that a particular trace, such as one
generated by a ~clang~ executable, is part of this set.

** TODO More complex programs

A goal for the near future of this project is to generate more complex
programs with fewer constraints. The programs that we currently
generate are *heavily* constrained in order to be deterministic,
terminating, and safe.

Our CFGs currently have no back-edges, making it easy to think about
whether a program terminates (it does). Unfortunately, this means that
the generated programs are very boring.

It may be interesting to explore timeout mechanisms, instead of
ensuring that programs terminate, as this is something that Csmith
seems to do as well.

** More complex testing

*** I/O and traces

The current testing framework relies exclusively upon the return value
of programs. Testing that programs perform the same (or equivalent)
I/O operations would also be interesting. Capturing and comparing
~stdout~ should not be too difficult as a first approximation, but
generating programs that read structured data from ~stdin~, and then
automatically generating this data while testing could be interesting
future work.

*** TODO Other properties (eutt)

In theory we would also like to be able to test other properties
(aside from just testing Vellvm against clang). One important property
that we would like to test is eutt, or "equivalence up to tau", 

** Speed

Generating and running the tests is currently quite slow. Benchmarking
the time spent generating test cases and the time spent running tests
could help us improve this. For instance, we might find that much of
our time is spent running tests because we have to write our program
out to a file and then call ~clang~ on it. Working on making larger
test cases could ensure that each call to ~clang~ makes us as likely
as possible to generate
